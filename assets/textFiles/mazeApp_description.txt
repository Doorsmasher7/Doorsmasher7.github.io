With this project we were tasked by an imaginary client (officially QUT) to create a maze editing tool.  Their company has been experiencing an increased demand from their clients and designing the mazes by hand has been taking too long.  To increase the efficiency of their workers the maze app should be able to randomly generate mazes, allow for manual editing, allow for importing of images to be placed within the maze, show the solution to the maze, save and load the mazes and allow the mazes to be exported as a JPG for publication.

For this project, I acted as the team leader and while I was responsible for overseeing every aspect of the project, I was specifically in charge of designing and implementing the back-end system to track and manage the maze itself.  The project was developed entirely in Java and through this development I gained a deeper understanding of just-in-time languages and their significant advantages and disadvantages.  With the exception of UI libraries, we were not allowed to utilize existing libraries or frameworks for this project and as such I created everything from scratch including all relevant classes for the grid (maze Class, Node class, solver class, etc).  The data structure for the maze itself was nothing special as the node objects were store in a simple 2D array and each node could be represented as a string of 13 characters to be saved into the database.  During the development of this feature, I implemented a depth-first random maze generation algorithm to fulfill the client’s requirements that would always generate a new maze with a guaranteed solution.  To solve the maze, I implemented an A-Star pathfinding algorithm so that way a check could be put in place to determine if the maze is solvable and also to show the solution visually to the user as they’re editing.  

Through my role as team leader, I ended up assisting everyone with the difficult challenges that were faced during development.  The most taxing of which was integrating the ability to save the maze’s to a database (in this case a HeidiSQL server) to then be later reloaded by the user.  The issue was that if we attempted to save the maze data in the form of a string, we would routinely hit the character limit that the database would allow us to store (ie. 65565 characters) and as such be unable to store that maze.  Our initial instinct was to reduce the number of characters that each node required, however in doing so we forfeited some vital information that later proved to be necessary.  The solution we eventually settled on was to limit the maximum size of the maze to be 50x50 rather than 100x100.  This decision was practical for the user as well because editing a 100x100 maze given our UI set up was tedious and we determined that it was unrealistic for any user to actually manually edit a maze of that size.  We kept the option in the program to do so just in case, but added a warning that mazes above 50x50 could not be saved, only exported.
